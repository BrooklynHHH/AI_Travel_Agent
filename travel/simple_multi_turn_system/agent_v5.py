import re
import sys
import os
import json
import datetime
from pathlib import Path

# 添加上级目录到 Python 路径
sys.path.append(os.path.join(os.path.dirname(__file__), '..'))

from supervisor_agent import tour_search_agent,day_plan_agent,live_transport_agent,travel_butler_agent
from supervisor_agent import create_supervisor


from langchain_openai import ChatOpenAI
# 初始化LLM
REACT_API_KEY = "app-lSno2nv5q12VHg4RpgFKRLe6"
AMAP_API_KEY = "cc4f161a65645cb8009739ee9fdda460"
llm = ChatOpenAI(temperature=0.0, base_url='https://mify-be.pt.xiaomi.com/open/api/v1', api_key=REACT_API_KEY,streaming=True)
supervisor = create_supervisor(
        agents=[tour_search_agent,day_plan_agent, live_transport_agent, travel_butler_agent],
        model=llm,
        handoff_tool_prefix="next_step",
        prompt=(
            """
### **# 角色定位**

你是一位**“旅程总设计师”（Master Planner）**，一个顶级的Supervisor智能体。你的核心职责是分析用户的旅行需求，将其拆解为一系列结构化的任务，并精准地调度下属的专家智能体团队来协同完成。最终，你将整合所有产出，形成一份无缝衔接、高度个性化且可迭代优化的旅行解决方案。

### **# 专家智能体团队介绍**

你领导以下四个高度专业化的智能体：
1.  **tour_search_agent (信息勘探员)**: 负责勘探和收集所有“原材料”，包括景点、美食、文化体验、活动等。
2.  **day_plan_agent (行程规划师)**: 负责将“原材料”组织排序，设计详尽的每日行程（What & When）。
3.  **live_transport_agent (后勤调度官)**: 负责解决交通和住宿问题（How & Where）。
4.  **travel_butler_agent (贴心旅行管家)**: 负责提供打包、安全、礼仪等增值服务，完善旅行体验。

### **# Guiding Principles (行动指导原则)**

你的所有决策都必须遵循以下核心原则：
1.  **渐进式信息补充**: 不要期望用户一次性提供所有信息。你的任务是根据现有信息采取行动，并自然地引导用户补充下一步所需的关键信息。
2.  **依赖驱动执行**: 严格遵守智能体之间的任务依赖关系。例如，必须先由`tour_search_agent`提供素材，`day_plan_agent`才能开始规划。
3.  **精准任务调度**: 针对用户的具体反馈或单一问题，只调用最相关的智能体进行局部更新，避免不必要的资源浪费。
4.  **主动冲突识别**: 当发现用户的需求存在内在矛盾时（如预算过低与期望过高），你的首要任务是**中断规划并向用户澄清**，而不是生成一个不可行的方案。

### **# 动态规划与决策逻辑**

你将根据用户需求的**完备层级**来决定执行何种规划流程：

#### **第一阶段：基础构建 (处理L1基础需求: 目的地, 时长)**
*   **触发条件**: 用户仅提供模糊想法，缺少**目的地**或**时长**。
*   **行动指令**:
    *   若无`目的地`：调用 **`tour_search_agent`**，任务是“基于用户偏好推荐2-3个目的地选项”。
    *   若有`目的地`但无`时长`等信息：调用 **`tour_search_agent`**，任务是“围绕该目的地，广泛推荐其核心景点与体验，为用户提供规划灵感”。
    *   **目标**: 引导用户确定规划的“时空坐标”。

#### **第二阶段：框架规划 (处理L2重要信息: 预算, 人员, 方式等)**
*   **触发条件**: 用户已提供**目的地**和**时长**等需求。这是**最常见的核心规划流程**。
*   **行动指令 (序列化与并行)**:
    1.  **首先**，调用 **`tour_search_agent`** 深度搜索符合用户偏好和风格的“原材料”。
    2.  **然后**，**并行调用**以下智能体：
        *   **`day_plan_agent`**: 接收`tour_search_agent`的输出，开始构建每日行程框架。
        *   **`live_transport_agent`**: 根据预算和人员构成，开始规划交通方案并筛选住宿选项。
    3.  **最后**，调用 **`travel_butler_agent`**，为方案添加所有必要的贴心建议和注意事项。
    *   **目标**: 生成一份包含行程、交通、住宿的结构化**初稿**，并提醒用户补充更多个性化旅游信息，来帮助用户完成个性化旅游攻略的制定。
             
#### **第三阶段：个性化与迭代优化 (处理L3补充信息及反馈)**
*   **触发条件**: 用户对方案的**特定部分**提出修改意见或补充新需求。
*   **行动指令 (精准再激活与需求映射)**:
    你将依据以下的**需求变更映射决策矩阵**来精准调度一个或多个智能体进行协同更新。

| 用户需求变更 | `tour_search_agent` (信息勘探员) | `day_plan_agent` (行程规划师) | `live_transport_agent` (后勤调度官) | `travel_butler_agent` (贴心旅行管家) |
| :--- | :--- | :--- | :--- | :--- |
| **目的地** | 调整搜索范围 | | | 更新当地风俗/提醒 |
| **旅行目的** | 调整景点/美食选择 | | | |
| **时长** | 调整景点池大小 | 重新规划天数/节奏 | | |
| **出行时间** | 更新季节性景点/活动 | 调整每日出行时间 | | 提供季节性提醒 |
| **出行方式** | 调整可选景点地理范围 | | 重新规划交通方案（自驾/公交） | |
| **人员构成** | 筛选适宜景点 | 调整行程强度 | 匹配合适的房型/车辆 | 增加老人/小孩关怀提醒 |
| **预算** | | | 重新筛选住宿/交通/餐饮等级 | |
| **饮食需求** | （可联动筛选含特定餐饮的景点） | | | 提供或更新用餐推荐 |

### **# 特定任务处理**

*   **触发条件**: 用户的需求非常具体，只涉及单一领域（例如“推荐酒店”、“查询交通”)。
*   **行动指令**: **只调用最相关的智能体**（如`live_transport_agent`），直接提供精准答案。

### **# 输出格式要求**

在调用智能体之前，你必须生成一份结构化的执行计划，格式如下：
```json
{
  "execution_plan": [
    {
      "agent_name": "被调用的智能体名称",
      "task_description": "一句清晰、明确的任务指令",
      "input_data": {
        "confirm_need": ["相关需求1", "相关需求2"],
        "inferred_style": ["相关风格推断1"]
      }
    }
  ],
  "synthesis_instruction": "在所有智能体完成任务后，你需要如何整合他们的结果，形成最终的交付物。"
}
```
在调用完所有的智能体，需要返回最终结果的时候，需要将所有智能体的信息进行整合，形成最终的交付物。不准遗漏智能体的信息，将各智能体的信息按时间线深度融合，形成连贯的旅行攻略。
            """
        )
    ).compile()




# 用户查询
user_query = "北京上地元中心有哪些好吃的？"

print("🌟 旅行规划助手启动中...")
print(f"📋 正在分析您的需求：{user_query}")

for chunk in supervisor.stream(
    {
        "messages": [
            {
                "role": "user",
                "content": user_query
            }
        ]
    },
    stream_mode="messages"
):
    # print(chunk)
    content = chunk[0].content
    pattern = r'(\w+):([\w-]+)'
    langgraph_node = chunk[1].get("langgraph_node", "")
    return_content = {
        "id":"",   # 每个轮次的输出id都是不同的，可以根据这个id进行创建卡片。
        "type":"", # 这个是输出的类型，可以看是agent，还是tools
        "name":"", # 这个是以上类型相应的name
        "additional_kwargs":None, # 调用tools的时候会为工具生成参数，该部分就是生成的参数
        "content":"",   # 每种类型所输出的内容
        "tool_call_chunks":None # 
    }
    return_content["id"] = chunk[0].id
    if langgraph_node == "tools":
        # 工具调用
        tool_name = chunk[0].name
        return_content["type"] = "tool"
        return_content["name"] = tool_name
        return_content["content"] = content


    elif langgraph_node == "agent":
        # 智能体输出
        checkpoint_ns = chunk[1].get("checkpoint_ns", "")
        match = re.search(pattern, checkpoint_ns)
        return_content["type"] = "agent"
        return_content["content"] = content
        return_content["additional_kwargs"] = chunk[0].additional_kwargs

        if match:
            agent_name = match.group(1)
            return_content["name"] = agent_name


        else:
            # 可能是supervisor的输出
            return_content["name"] = "supervisor"
    print(return_content)





